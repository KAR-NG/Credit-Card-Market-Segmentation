---
title: "Credit card Market Segmentation by Auto-Clustering"
author: "Kar Ng"
date: '2022-05'
output: 
  github_document: 
    toc: true
    toc_depth: 4
always_allow_html: yes
---


## 1 R PACKAGES

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(kableExtra)
library(skimr)
library(factoextra)
library(hopkins)
library(clValid)
library(NbClust)
library(mclust)
library(cowplot)
library(dbscan)
library(fpc)
library(corrplot)
library(FactoMineR)
library(ggiraphExtra)   # for radar 
library(GGally)         # for ggparcoord

```



## 2 INTRODUCTION

This project will use clustering technique to develop a customer segmentation to define marketing strategy. 

Dataset used in this project is called "Credit Card Dataset for Clustering" by Arjun Bhasin. It is a public dataset acquired from [Kaggle.com](https://www.kaggle.com/datasets/arjunbhasin2013/ccdata).

The dataset has 17 behavioral information of about 9000 active credit card holders.

## 3 DATA PREPARATION

### 3.1 Data Import

Following codes import the dataset and specify the first column as row's name, as it is required to perform clustering. 

```{r}
cc <- read.csv("cc_dataset.csv",
               header = T,
               row.names = 1)   # specificy column 1 as row name 

```

randomly sample the first 10 rows of the dataset. 

```{r}
sample_n(cc, 10)

```

The name of all variables are:

```{r}
names(cc)

```


### 3.2 Data Description

Following is the data description extracted from the kaggle website.

```{r}

Variables <- c("CUSTID", "BALANCE", "BALANCEFREQUENCY", "PURCHASES", "ONEOFFPURCHASES",
               "INSTALLMENTSPURCHASES", "CASHADVANCE", "PURCHASESFREQUENCY", "ONEOFFPURCHASESFREQUENCY", "PURCHASESINSTALLMENTSFREQUENCY", "CASHADVANCEFREQUENCY", "CASHADVANCETRX", "PURCHASESTRX", "CREDITLIMIT", "PAYMENTS", "MINIMUM_PAYMENTS", "PRCFULLPAYMENT", "TENURE")

Description <- c("Identification of Credit Card holder (Categorical)",
                 "Balance amount left in their account to make purchases",
                 "How frequently the Balance is updated, score between 0 and 1 (1 = frequently updated, 0 = not frequently updated)",
                 "Amount of purchases made from account",
                 "Maximum purchase amount done in one-go",
                 "Amount of purchase done in installment",
                 "Cash in advance given by the user",
                 "How frequently the Purchases are being made, score between 0 and 1 (1 = frequently purchased, 0 = not frequently purchased)",
                 "How frequently Purchases are happening in one-go (1 = frequently purchased, 0 = not frequently purchased)",
                 "How frequently purchases in installments are being done (1 = frequently done, 0 = not frequently done)",
                 "How frequently the cash in advance being paid",
                 "Number of Transactions made with Cash in Advanced",
                 "Number of purchase transactions made",
                 "Limit of Credit Card for user",
                 "Amount of Payment done by user",
                 "Minimum amount of payments made by user",
                 "Percent of full payment paid by user",
                 "Tenure of credit card service for user")


data.frame(Variables, Description) %>% 
  kbl() %>% 
  kable_styling(bootstrap_options = c("bordered", "stripped"))

```

### 3.3 Data Exploration

**Data Size and type**

The dataset contain 8950 rows and 17 variables. The "dbl" and "ind" are data type allocated by R to a particular column. The "dbl" stands for "double", it is used for numerical variables that have decimal places. The "int" stands for integer, it is used for numerical variables that have integer values. All variables are numeric with either "dbl" and "int", they will be treated the same type during analysis.

```{r}
glimpse(cc)

```
**Purchases**

During exploration, I found that "PURCHASES" is the sum of "ONEOFF_PURCHASES" and "INSTALLMENTS_PURCHASES". It may not be important in this analysis.

Following select 10 rows among the dataset, and the new variable "MY_PURCHASES" proves my finding, which is the same as the "PURCHASES", and is the sum of "ONEOFF_PURCHASES" and "INSTALLMENTS_PURCHASES".

```{r}
cc %>% 
  top_n(10, BALANCE) %>% 
  dplyr::select(ONEOFF_PURCHASES, INSTALLMENTS_PURCHASES, PURCHASES) %>% 
  mutate(MY_PURCHASES = ONEOFF_PURCHASES + INSTALLMENTS_PURCHASES)

```

**Missing values check**

Again, proven by other function that the tables have 8950 rows of data and 17 variables. All variables are numerical, and, by examining the variables "n_missing" and "complete_rate" in following tables, there is 1 missing value in the variable "CREDIT_LIMIT" and 313 in the "MINIMUM_PAYMENTS". These missing values need to be handled. 

```{r}
skim_without_charts(cc)

```
Alternatively, following code performs the missing-value check.

```{r}
colSums(is.na(cc))

```
There are 8950 rows of data and I will still have 96.5% of data left after removal of these missing values and therefore I will simply remove these missing values for the simplicity of this project.

Typically, missing value can be handled by either removal, replaced with mean, median, or using imputation algorithm such as KNN or bagging algorithm. These techniques are usually performed when there are too many missing values in important variables. For example, when missing values is higher than 5% and less than 60%. 


**Summary**

Visualising the statistical distribution of each variable:

```{r}
summary(cc) %>% kbl() %>% kable_styling(bootstrap_options = c("bordered", "stripped"))

```


## 4 DATA CLEANING AND MANIPULATION

### 4.1 Rename all variables

The name of all variables are in capital form and which would be difficult to read for readers and also myself.

```{r}
colnames(cc)
```
Following code transforms all the name into reading-friendly form. 

```{r}
cc <- cc %>% 
  rename_all(str_to_sentence)

```

Checking again the name of each variable.

```{r}
colnames(cc)

```

### 4.2 NA Removal

Following code remove all the missing values in the dataset (314 rows among 8950 rows)

```{r}
cc <- cc %>% 
  na.omit()

```

Now, the number of rows have been reduced to 8636 from 8950. 

```{r}
str(cc)
```

## 5 EDA

### 5.1 Histogram

**Distribution Study**

A primary exploratory data analysis is suggested to quickly understand the general distribution of the data.  

```{r, fig.height=10, fig.width=13, message=FALSE, warning=FALSE}

# data frame

cc2 <- cc %>% 
  pivot_longer(c(1:17), 
               names_to = "my.variable", 
               values_to = "my.value")

# graphs

ggplot(cc2, aes(x = my.value, fill = my.variable)) +
  geom_histogram(color = "black") +
  facet_wrap(~my.variable, scale = "free") +
  theme_minimal() +
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45),
        plot.title = element_text(face = "bold", hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5, face = "bold")) +
  labs(title = "Variable Distribution Analysis",
       subtitle = "by Histogram")


```

Most of the variables follow Pareto trend (80:20 rule) with majority of the data belong to one side of the value. it can be seem quite hard to group the data and categories the data into several distinct group for marketing purposes.

### 5.2 Corrplot

Following plot shows the relationship between variables. 

```{r}
cor_cc <- cor(cc)

corrplot(cor_cc, type = "upper", tl.cex = 0.6)


```

### 5.3 PCA

This section I will use principal component analysis (PCA) to help my exploratory data analysis by reducing the number of variables into a few principal components. 

This first step is general recommended to scale the data (standardisation) so that variables with different units will no be comparable. 

```{r}
cc.scale <- scale(cc)
```

Showing the first 6 rows of the data:

```{r}
head(cc.scale)

```

Applying principal component algorithms.

```{r}

res.pca <- PCA(cc.scale, graph = F)

```


```{r}
fviz_screeplot(res.pca, addlabels = T, ylim = c(0, 30), barfill = "orange", barcolor = "black") +
  labs(title = "Scree Plot") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

```
```{r}
27.2 + 20.4+8.9 + 7.6+6.3 +5.7 + 4.9 + 4.2 + 3.7 + 3.1
```

```{r, fig.height=12, fig.width=10}
pca1 <- fviz_contrib(res.pca, choice = "var", axes = 1, top = 10)
pca2 <- fviz_contrib(res.pca, choice = "var", axes = 2, top = 10)

pca3 <- fviz_pca_var(res.pca, repel = T,
             col.var = "contrib",
             gradient.cols = c("green", "green2", "darkgreen")) +
    labs(title = "Factor Map: Variable - PCA") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))


pg <- plot_grid(pca1, pca2)
plot_grid(pg, pca3, cols = 1)


```

Most influential variables:

1. Purchases, Purchases_trx, Oneoff_purchases, installments_purchases, purchases_frequency

2. Cash_advance, cash_advance_frequency, cash_advance_trx

Component 1 is more about purchases made and component 2 is more about cash in advanced requested by customers. 


## 6 CLUSTERING

The dataset must met several conditions prior to be clustered,

1. Observation as row and variable as variable, and it has been met.  

2. No missing values in the dataset, and it has been met. 

3. Standardising the data (generally recommended) to make variables comparable. This step will transform the data in all variables to a scale that would have 0 mean and 1 standard deviation. This step has been met in the PC section.   

There are different type of clustering methods such as partitioning clustering which include "k-means clustering", "PAM", and "CLARA", or hierarchical clustering which include the famous "AGNES" and "DIANA". 

Partitioning and hierarchical clustering methods are alternative to each other, and although automation with selection statistics are available to choose the best algorithm for the dataset but I will not perform it here as the data size is too large to handle within a convenient time frame. However, complete proper steps of clustering will be performed along with several advanced clustering technique. Ultimately, I will pick a result from a clustering technique for visualisation. 

### 6.1 Cluster-Tendency Assessment

There is a big issue with clustering techniques is that it will always return clusters even if there is no any cluster in the dataset. Therefore, clustering tendency assessment is an important step to test is there clusters in the dataset. 

**Hopkins Statistics** is a statistical method that using probability to test for spatial randomness of the data. The null hypothesis is that the credit card dataset is uniformly distributed, indicating no meaningful cluster. 

* If the value of hopkins statistic is low (0 - 3), it indicates regularly-spaced data. Indecisive (clustered or random).  
* if the value is around zero, it indicates random data   
* If the value is around 0.7 to 1, it is a significant evidence that the data might be clusterable

```{r}
hopkins(cc.scale, m = nrow(cc.scale)-1)

```
The Hopkins Statistics is 1, and base on this value I can reject the null hypothesis and conclude that the credit card dataset is significantly a clusterable data.

Following is the same test from other R package and yield the similar result. 

```{r}
get_clust_tendency(cc.scale, n = 100, graph = F)


```

### 6.2 CLARA

I have picked CLARA as the clustering algoritm to perform for this dataset because this dataset has more than thousand of observations (Alboukadel Kassambara 2017). CLARA stands for "Clustering Large Application", which is an extension of PAM (Partitioning Around Medoid), and PAM is a robust alternative to the K-mean clustering that because it is less sensitive to outlier. 

As the name of CLARA suggests, I apply CALARA because this dataset is a large dataset and CLARA can help to reduce computation time and RAM storage issue by a sampling approach. I didn't pick hierarchical clustering (AGNES and DIANA) for this project because of the same reason, CLARA is desgined for large application.


```{r, fig.width=14, fig.height=8}
res.clara2 <- eclust(cc.scale, 
                    FUNcluster = "clara",
                    k = 2,
                    graph = F)

res.clara3 <- eclust(cc.scale, 
                    FUNcluster = "clara",
                    k = 3,
                    graph = F)

res.clara4 <- eclust(cc.scale, 
                    FUNcluster = "clara",
                    k = 4,
                    graph = F)

res.clara5 <- eclust(cc.scale, 
                    FUNcluster = "clara",
                    k = 5,
                    graph = F)

res.clara6 <- eclust(cc.scale, 
                    FUNcluster = "clara",
                    k = 6,
                    graph = F)

res.clara7 <- eclust(cc.scale, 
                    FUNcluster = "clara",
                    k = 7,
                    graph = F)


f1 <- fviz_cluster(res.clara2, show.clust.cent = F, geom = "point", alpha = 0.5, palette = "jco") + 
  theme_classic() + labs(title = "Cluster plot (K = 2)")

f2 <- fviz_cluster(res.clara3, show.clust.cent = F, geom = "point", alpha = 0.5, palette = "jco") + 
  theme_classic() + labs(title = "Cluster plot (K = 3)")

f3 <- fviz_cluster(res.clara4, show.clust.cent = F, geom = "point", alpha = 0.5, palette = "jco") + 
  theme_classic() + labs(title = "Cluster plot (K = 4)")

f4 <- fviz_cluster(res.clara5, show.clust.cent = F, geom = "point", alpha = 0.5, palette = "jco") + 
  theme_classic() + labs(title = "Cluster plot (K = 5)")

f5 <- fviz_cluster(res.clara6, show.clust.cent = F, geom = "point", alpha = 0.5, palette = "jco") + 
  theme_classic() + labs(title = "Cluster plot (K = 6)")

f6 <- fviz_cluster(res.clara7, show.clust.cent = F, geom = "point", alpha = 0.5, palette = "jco") + 
  theme_classic() + labs(title = "Cluster plot (K = 7)")

plot_grid(f1, f2, f3, f4, f5, f6,
          ncol = 3,
          nrow = 2)

```

From above visualisation, I can see how the data partitions change when K is increased. We can see clearly how each partition is formed. 

Following shows the silhouette width of each observation in each k. 

The line in the middle of the graph is the overall average silhouette width of each k, the higher silhouette width, the better the quality of a clustering or an observation.  

In following plots, it can be interpreted as this (Alboukadel Kassambara 2017):

* Observations with a large Silhouette value are very well clustered  
* Observations with a small silhouette value means they lies between two clusters  
* Observations with a negative Silhouette are probably assgined to the wrong cluster. However, negative values may be unavoidable.

```{r, fig.width=14, fig.height=8}

f7 <- fviz_silhouette(res.clara2, palette = "jco")
f8 <- fviz_silhouette(res.clara3, palette = "jco")
f9 <- fviz_silhouette(res.clara4, palette = "jco")
f10 <- fviz_silhouette(res.clara5, palette = "jco")
f11 <- fviz_silhouette(res.clara6, palette = "jco")
f12 <- fviz_silhouette(res.clara7, palette = "jco")

plot_grid(f7, f8, f9, f10, f11, f12,
          ncol = 3,
          nrow = 2)

```

Instead of choosing the clustering manually, there are methods to suggest the best K.

Now I will use two typical methods among other popular methods to find the optimal number of clusters (specified by "k") that the dataset is able to be clustered into. All methods should recommend the same or highly similar value of optimal k.

In general, the optimal k is specified by the analyst of the project, and it can a hard task. There is also no definite answer to say what k is the best, it is subjective and relying on the selection of the distance matrix and the parameters used for clustering the data.


**Elbow Method:**

Following shows the result of Elbow method. In Elbow method, clustering algorithm is computed for different number of clusters (k). For each k, the total within sum of square (WSS) is calculated.

The location of a bend (knee) is generally considered as an indicator of appropriate k. 

```{r}
fviz_nbclust(cc.scale, FUNcluster = clara, method = "wss")
```

The concept of elbow method is that it will suggest an optimal k in a way that any additional cluster will not affect the statistics significantly. 


**Silhouette Method**

This method uses average silhouette width to determine the optimal number of k. A high average silhouette width means good clustering. Additionally, the algorithm will suggest the best k for the credit card dataset, which is 9, although k-7 was also not too bad in term of average silhouette width and is not too far away k-9.


```{r}
fviz_nbclust(cc.scale, FUNcluster = clara, method = "silhouette")
```

**Analysing the result**

According to the suggested number of clusters, I will go for the cluster number of 2.

Adding the cluster to the scaled original data:

```{r, fig.height=12, fig.width=12}

# 1 Radar plot 

clara_k2 <- cbind(as.data.frame(cc.scale), 
                  cluster = res.clara2$clustering) %>%  # merge scaled data with clusters
  mutate(cluster = as.factor(cluster)) %>% 
  relocate(cluster, .before = Balance)

g1 <- ggRadar(clara_k2, aes(group = cluster),
        size = 1,
        use.label = T, 
        rescale = F) +        
  # Use scaled data to plot Radar, do not normalise btw 1-0 by rescale = T.
  # scaled data better show subtle trends
  theme_bw()


# 2 Parallel coordinate

clara_k2_2 <- clara_k2 %>%           # merge original cleaned data with clusters
  group_by(cluster) %>% 
  summarise_all(median)

g2 <- ggparcoord(clara_k2_2, 
           column = c(2:17),
           groupColumn = "cluster",
           scale = "globalminmax", showPoints = T) +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) 


# 3 




plot_grid(g1, g2,
          nrow = 2)

```

```{r}
clara_k2
```

```{r}

clara.pca <- PCA(clara_k2, graph = F, quali.sup = 1)

fviz_

```

```{r}

df <- clara_k2[1:20,]
df

res.pca <- PCA(df,
               quali.sup = 1,
               graph = F)

fviz_pca_var(res.pca,
             col.v)


```





### 6.3 Hierarchical K-Means Clustering

In this section, I will perform hkmeans, which is a method that combine K-means clustering and hierarchical clustering to improve k-means results. 

The biggest limitation K-means clustering is that the final result is subjected to the initial random selection of centroids. However, in hkmeans, the selection of centroid is not based on randomisation but the results of hierarchical clustering from the hk-mean algorithm, these centroids are optimiased centroids. Therefore, in hierarchical k-means clustering, the hierarchial clustering is being performed first, followed by the k-means clustering. 

Following summarise the combination of the two algorithms :

* **Step 1**: Compute hierarchical clustering with the optimal K obtained from previous section. In this step, distance matrix between each pair of observation is computed and based on that, a linkage function is selected to group similar objects into hierarchical cluster tree. Each observation are considered a cluster on its on, then the forming of clustering move upward and form bigger cluster, and this step continues until the root is reached. Finally, the tree is cut into pre-specified K (which is 7 in this case). 

* **Step 2**: Compute the center (i.e. mean) of each cluster. Therefore, there are 7 new center here in each of the 7 clusters.

* **Step 3**: Compute K-means clustering on the original normalised credit card dataset by using the set of cluster centers computed in step 2 as the initial cluster centers. Then, according to the algorithm of K-means clustering, each observations will be assigned to the closest centroid based on distance matrix (eg. euclidean). For each k-clusters, a new mean is being updated again by calculating the new mean value of all data points in the cluster. Finally, all observations are being re-allocated to these new means. The allocation of observations and the calculation of new means are iterated until the total within sum of square is minimised.

Following code complete the hkmeans.

```{r}
# Create hierarchical k-means clustering

res.hk <- hkmeans(cc.scale, 
                 k = 7,
                 hc.metric = "euclidean",
                 hc.method = "ward.D2",
                 km.algorithm = "Hartigan-Wong")

```

The "res.hk" objects contain following results.

```{r}
# Items created from the object

names(res.hk)

```
The dataset can be clustered (grouped) in 7 clusters (group), estimated by this project, and these 7 clusters has following size:

```{r}
res.hk$size

```
Graphical presentation of the results: 

```{r}

hk.cluster <- fviz_cluster(res.hk,
                           palette = "jco",
                           geom = "point") 
  
hk.cluster + 
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5)) +
  labs(title = "Hierarchical K-means Clustering Results",
       subtitle = "Hartigan-Wong algorithm + Euclidean + ward.D2 + K = 7")
  
  
```

All the observation points are being converted and plotted onto dimensional plots (Dim1 & Dim2). The dataset has been detected that it is clusterable and optimal k was estimated as 7. However, there are several clusters overlapping with each other, I start to question are points really being clustered well? 

In traditional clustering such as partitioning and hierarchical clustering, observation points are assigned to exactly 1 cluster. In the next section, I will use fuzzy clustering which will give each point a probability value, and to see whether this algorithm will cluster the points better.


### 6.4 Fuzzy Clustering

This section performs an alternative to k-mean clustering. In K-mean clustering or PAM, observations are assigned to exactly 1 cluster. However, in fuzzy clustering, each observation has a probability of belong to each cluster. Points that close to the center of a cluster will have a higher probability than points that further away from a center of points that belong to other cluster.  


```{r}
res.fanny <- fanny(cc.scale, k = 7, metric = "euclidean", stand = FALSE, memb.exp = 1.05)

```

Showing the member coefficient

```{r}
head(res.fanny$membership, 10)

```


```{r}
head(res.fanny$coeff, 10)

```

Following code show the cluster that each observation belongs to (extracting the first 10 observations). 

```{r}
head(res.fanny$clustering, 10)

```

Visualising the clusters: 

```{r}

fviz_cluster(res.fanny, geom = "point", repel = T,
             palette = "jco")


```

Silhouette width (Si) is a type of interval cluster validation, with a range from 1 to -1. If an observation has a Si of closer than 1 then the point is well clustered, whereas if a point is close to -1 than it indicates that the point is poorly clustered and assigning this point to other cluster may improve the results. It can be understood that if a point has negative Si, it means that they are not in the correct cluster (Alboukadel Kassambara 2017).     


```{r}
fviz_silhouette(res.fanny, palette = "jco")

```

However, I will try to use other algorithms to see if they can better cluster the observations in this credit card dataset.

### 6.5 Model-Based Clustering

Model-based clustering also compute k-probabilities for each observation. However, this model-based clustering will suggest us the best k, as compared to hkmeans and fuzzy. 

Algorithm used in this model-based clustering is called Expectation-Maximisation algorithm (EM). In this algorithm, data are  considered as coming from a mixture of two or more clusters, and all clusters may have a mixture of density. 

The algorithm starts by hierarchical model-based clustering, and cut the dendrogram for different number of k. In each k, each cluster is centered at the means with increase density for points near the mean. 

The gemetric features (volume, shape, and orientation) of each cluster will then be determined. After this step, the similarity of volume, shape and orientation between clusters of that k will be determine using a standard parameteration.

Following code perform the model-based clustering:

```{r}
res.mc <- Mclust(cc.scale)

```
The best model is determined using the Bayesian Information Criterion or BIC. A large BIC indicates good model, and the model with highest BIC will be selected. 

The model-based clustering selected a model with 6 clusters (k), the optimal selected model name is VEV, it means varying volume, equal shape, and varying orientation on the coordinate axes. 

```{r}
summary(res.mc)
```

Visualising the outcome of cluster-based modeling:


```{r, fig.height=8, fig.width=12}

mc1 <-  fviz_mclust(res.mc, 
            what = "classification",
            geom = "point", 
            alpha = 0.1)

mc2 <- fviz_mclust(res.mc, what = "BIC")

mc3 <- fviz_mclust(res.mc, what = "uncertainty") + labs(subtitle = "Larger symbols indicate the more uncertain observations.")


pg1 <- plot_grid(mc1, mc2)

plot_grid(pg1, mc3,
          nrow = 2)

```












## REFERENCE

Arjun Bhasin 2018, *Credit card Dataset for Clustering*, viewed 10 May 2022, https://www.kaggle.com/datasets/arjunbhasin2013/ccdata

Alboukadel Kassambara 2017, *Practical Guide to Cluster Analysis in R*, Multivariate Analysis 1, Edition 1, sthda.com

Clustering and dimensionality reduction techniques on the Berlin Airbnb data and the problem of mixed data (n.d.),viewed 15 May 2022 https://rstudio-pubs-static.s3.amazonaws.com/579984_6b9efbf84ee24f00985c29e24265d2ba.html

Jenny Listman 2019, *Customer Segmentation / K Means Clustering*, viewed 14 May 2022, https://www.kaggle.com/code/jennylistman/customer-segmentation-k-means-clustering

Matt.0 2019, *10 Tips for Choosing the Optimal Number of Clusters*, viewed 12 May 2022, https://towardsdatascience.com/10-tips-for-choosing-the-optimal-number-of-clusters-277e93d72d92











